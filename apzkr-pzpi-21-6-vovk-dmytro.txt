Міністерство освіти та науки України 
Харківський національний університет радіоелектроніки 
Факультет комп’ютерних наук 
Кафедра програмної інженерії 
КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА  
з навчальної дисципліни «Архітектура програмного забезпечення» Тема роботи: Програмна система для бойової орієнтації та розпізнавання "Discerniy" 

Студент гр. ПЗПІ-21-6
__________________ Вовк Д.А.
(підпис)
Керівник роботи
___________________ ст.викл. Сокорчук І.П.
(підпис)
       Роботу захищено «18»_червня__2024 р.
       з оцінкою _________________________
Комісія:
___________________ доц. Лещинський В.О.
           (підпис)
___________________ доц. Лещинська І.О.
           (підпис)
___________________ ст.викл. Сокорчук І.П.
           (підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки  
Факультет комп’ютерних наук                  Кафедра програмної інженерії  _ 
Спеціальність 121 – Інженерія програмного забезпечення                          _ 
Курс _         3             Семестр _                                      6                               _
Навчальна дисципліна Архітектура програмного забезпечення                 _
ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ
Вовку Дмитру Андрійовичу 
1. Тема роботи: «Програмна система для бойової орієнтації та розпізнавання "Discerniy"»                                                                          _   
2. Термін узгодження завдання курсової роботи «_31_»_березня__ 2024 р.  
3. Термін здачі студентом закінченої роботи «_17_»__червня__ 2024 р.  
4. Вихідні дані до проєкту (роботи): В програмній системі передбачити: додавання нових користувачів, розподілення рівнів доступу, налаштування прав доступу користувачам, групування, система навігації. Розробити взаємодію з IoT пристроями. Використовувати ОС Windows 11, СКБД MongoDB, середовище розробки Microsoft Visual Studio 2022 та Visual Studio Code                                                               _
5. Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, аналіз предметної області, постановка задачі, проєктування  програмної системи, структура бази даних, кодування програмного  проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки                                                                                        _  
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень  схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки                              _ 
КАЛЕНДАРНИЙ ПЛАН


№
Назва етапів курсової роботи
Термін виконання
етапів роботи
Примітка
1 
Функціональна специфікація програмного проєкту 
31.03.2024 
виконано 
2 
Проєктування програмного проєкту 
25.04.2024
виконано 
3 
Кодування програмного проєкту 
08.06.2024
виконано 
4 
Оформлення пояснювальної записки 
16.06.2024
виконано 
5 
Захист курсової роботи 
18.06.2024
виконано 



Дата видачі завдання «_31_»___березня___2024 р.  

Керівник
______________ ст.викл. Сокорчук І.П.
       (підпис)



Завдання прийняв до виконання
ст.гр. ПЗПІ-21-6
______________                      Вовк Д.А.
       (підпис)



РЕФЕРАТ
Пояснювальна записка до курсової роботи: 73 с., 22 рис., 2 табл., 4 додатки, 11 джерел.
ГЕОЛОКАЦІЯ, МАПА, ОРІЄНТУВАННЯ, СВІЙ-ЧУЖИЙ, ПЕРЕНОСНИЙ ПРИСТРІЙ.
Метою розробки є програмна система для бойової орієнтації та розпізнавання "Discerniy".
Методи розробки базуються на використанні середовищ розробки Visual Studio 2022 та Visual Studio Code,  ASP.NET Core 8, фреймворку Angular 16, бази даних MongoDB 7,брокера повідомлень RabbitMQ та кеш сервера Redis.
У результаті, було розроблено систему як допоможе вести бій, таким чином, що командування бачитиме точну позицію солдата та інших роботизованих систем на мапі у реальному часі. Також вона допомагає у пошуково-рятувальних операціях та зменшує ризик “дружнього вогню” на полі бою.


ЗМІСТ

ВСТУП	6
1 Аналіз предметної області	8
1.1 Огляд наявних систем та технологій	8
1.2 Сучасні тенденції та нові технології	8
1.3 Концепція і рамки проєкту	9
1.4 Концепція і рамки проєкту	10
1.5 Аналіз можливих рішень	10
2 Постановка задачі	11
2.1 Окреслення концепції	11
2.2. Головна функціональність	12
2.3. Припущення та залежності	13
2.4. Рамки та обмеження проєкту	14
3 Проєктування програмної системи	16
3.1 Архітектурна модель системи	16
3.2 Гнучкість та масштабованість системи	17
3.3 Взаємодія IoT пристроїв із сервером	18
3.4 Робота з даними	18
3.5 Авторизація	19
3.6 Конфігурація системи	19
3.7 Система дозволів	20
4 Структура бази даних	21
5 Кодування програмної системи	24
5.1 Опис серверної частини системи	24
5.2 Опис вебчастини системи	33
5.3 Опис реалізації IoT	36
6 Опис розробленої програмної системи	38
Висновки	48
Перелік посилань	50
ДОДАТОК А Реалізація серверної частини	52
ДОДАТОК Б Реалізація вебклієнта	64
ДОДАТОК В Реалізація IoT пристрою	73
ДОДАТОК Г Діаграми	77

ВСТУП


В умовах сучасних військових конфліктів і динамічно змінюваного бойового середовища, здатність швидкої та точної ідентифікації об'єктів на полі бою стає ключовим фактором для забезпечення ефективності військових операцій та збереження життів. З огляду на це, розробка та впровадження системи ідентифікації об'єктів на основі IoT технологій стає надзвичайно актуальною.
Актуальність теми. Система, яка розглядається в даній курсовій роботі, має на меті автоматизацію процесу ідентифікації об'єктів шляхом використання пристроїв Інтернету речей (IoT). Кожен об'єкт, хай то військовослужбовець або автоматизована/безпілотна система, оснащується IoT пристроєм, який постійно надсилає дані про свою геолокацію на центральний сервер. Це дозволяє оперативно відображати місцеперебування всіх об'єктів на інтерактивній карті, доступній кожному солдату на його мобільному пристрої.
Мета роботи. Метою даної курсової роботи є розробка програмної системи для бойової орієнтації та розпізнавання "Discerniy" на основі IoT технологій.
Завдання дослідження.
Проаналізувати сучасні технології ідентифікації об'єктів на полі бою.
Розробити архітектуру системи "Discerniy".
Реалізувати програмні компоненти системи.
Провести тестування та оцінку ефективності розробленої системи.
Об'єкт дослідження. Об'єктом дослідження є процес ідентифікації та відстеження об'єктів на полі бою.
Предмет дослідження. Предметом дослідження є програмна система для бойової орієнтації та розпізнавання "Discerniy", що використовує IoT технології для ідентифікації об'єктів.
Методи дослідження. Для досягнення мети дослідження будуть використані методи аналізу, проєктування, програмування та тестування програмних систем.
Практичне значення. Використання такої системи має ряд важливих переваг. По-перше, вона сприяє покращенню ситуаційної обізнаності, що дозволяє військовим швидко орієнтуватися на місцевості та приймати більш обґрунтовані рішення, що знижує ризик потрапляння під вогонь противника та підвищує загальний рівень безпеки. По-друге, система дозволяє командуванню в реальному часі бачити точні позиції солдатів та роботизованих систем, що значно покращує координацію бойових дій і підвищує ефективність виконання поставлених завдань. Крім того, ця технологія є надзвичайно корисною для проведення пошуково-рятувальних операцій на полі бою. Дані про геолокацію, які транслюються кожним солдатом, дозволяють оперативно знаходити поранених і надавати їм необхідну допомогу, а також уникати випадків «дружнього вогню», що є критично важливим для збереження життів військових.

1 Аналіз предметної області
1.1 Огляд наявних систем та технологій


1.1.1 Концепція і рамки проєкту
В сучасних умовах військових конфліктів виникає необхідність швидкої ідентифікації різного роду об'єктів на полі бою, таких як військовослужбовці або автоматизовані/безпілотні системи. Для автоматизації процесу ідентифікації кожен об'єкт оснащується IoT пристроєм, який надсилає дані про геолокацію на центральний сервер. Ця інформація дозволяє солдатам бачити розташування об'єктів на інтерактивній карті своїх мобільних пристроїв, що покращує орієнтацію на місцевості та підвищує безпеку.
1.1.2 Бізнес-можливості
Розробка системи "Discerniy" спрямована на оборонний сектор. Основними конкурентами є компанії L3Harris Technologies та Rheinmetall, які також пропонують системи ідентифікації "свій-чужий" (IFF). Однак, система "Discerniy" має ряд переваг, таких як нижча вартість, простота експлуатації, висока стійкість до кібератак, гнучкість та масштабованість.


1.2 Сучасні тенденції та нові технології


1.2.1 IoT технології
Інтернет речей (IoT) активно використовується для розробки систем ідентифікації об'єктів. Завдяки IoT пристроям можна забезпечити безперервний моніторинг та передачу даних про геолокацію об'єктів у реальному часі. Це значно покращує ситуаційну обізнаність військовослужбовців та командування.
1.2.2 Кіберзахист
Захист даних є ключовим аспектом для військових систем. Вбудовані заходи кіберзахисту, такі як часта зміна ключів шифрування та захищене з'єднання, забезпечують надійну захищеність системи "Discerniy" від потенційних загроз.


1.3 Концепція і рамки проєкту


Системи IFF від L3Harris Technologies та Rheinmetall мають ряд недоліків, таких як висока вартість, складність в експлуатації, програмні помилки та уразливість до кібератак. Ці проблеми можуть обмежувати їх ефективність та доступність для військових підрозділів з обмеженим бюджетом


1.4 Концепція і рамки проєкту


Функціональні вимоги:
Надання даних про геолокацію об'єктів у реальному часі;
Відображення розташування об'єктів на інтерактивній карті;
Підтримка захищеного з'єднання та часта зміна ключів шифрування.
Нефункціональні вимоги:
Висока стійкість до кібератак;
Простота встановлення та експлуатації;
Низька вартість та доступність для військових підрозділів з обмеженим бюджетом.


1.5 Аналіз можливих рішень


Проєкт "Discerniy" має переваги перед конкурентами завдяки низькій вартості, простоті експлуатації, високій стійкості до кібератак, гнучкості та масштабованості. Це робить його більш привабливим для військових підрозділів.
2 Постановка задачі
2.1 Окреслення концепції


2.1.1 Концепція проєкту
Проєкт "Discerniy" передбачає створення програмної системи для бойової орієнтації та розпізнавання, яка використовує IoT пристрої для ідентифікації об’єктів на полі бою. Система забезпечує високу стійкість до радіоелектронної боротьби та безпечне з'єднання завдяки частій зміні ключів шифрування. Вона дозволяє кожному солдату бачити на своєму пристрої всі об’єкти, які його оточують, і транслює дані про геолокацію в центральну мережу для підвищення ситуаційної обізнаності командування.
2.1.2 Проблема
Сучасні військові операції вимагають швидкої та точної ідентифікації об’єктів на полі бою, щоб уникнути дружнього вогню, забезпечити безпеку солдатів і підвищити ефективність бойових дій. Наявні системи ідентифікації, такі як IFF від L3Harris Technologies та Rheinmetall, мають значні недоліки, включаючи високу вартість, складність у використанні. Це створює потребу у доступній, надійній і простій у використанні системі, яка може ефективно працювати в умовах сучасного бойового середовища.
2.1.3 Потенційні користувачі:
Військові підрозділи;
Оборонні організації;
Військові навчальні заклади для тренувань та інструктажу.
2.1.4 Очікувані переваги
Підвищення безпеки солдатів: Забезпечення солдатів інформацією про навколишнє оточення в реальному часі, що зменшує ризик втрат і підвищує ефективність бойових операцій.
Ефективність пошуково-рятувальних операцій: Забезпечення точного визначення місцеперебування поранених або зниклих солдатів для швидкої організації рятувальних операцій.
Доступність та простота експлуатації: Зниження витрат на придбання та експлуатацію системи, що робить її доступною для військових підрозділів з обмеженим бюджетом. Простота встановлення та використання зменшує необхідність у додатковій підготовці персоналу та технічній підтримці.
Гнучкість та масштабованість: Система ефективно працює на різних відстанях та в різних умовах, легко інтегрується з наявними оборонними системами та мережами, що підвищує її ефективність у різних військових сценаріях.


2.2. Головна функціональність


MF-1: Авторизація у системі.
MF-2: Розділення користувачів за рівнем доступу.
MF-3: Детальний перелік дозволів користувача.
MF-4: Адміністрування переліку користувачів.
MF-5: Адміністрування переліку роботизованих систем.
MF-6: Адміністрування переліку груп.
MF-7: Трансляція геолокації об’єкта у систему.
MF-8: Відображення переліку об’єктів, які оточують користувача у вказаному радіусі (задається командуванням у налаштуваннях користувача) на мапі.
MF-9: Налаштування зон відповідальності групи користувачів.


2.3. Припущення та залежності


Технології та розробка. Використання передових технологій у всіх аспектах розробки системи, що забезпечить покращений користувацький досвід та високу гнучкість системи.
Інтеграція з зовнішніми постачальниками. Залежність від ефективної взаємодії з постачальниками компонентів IoT пристроїв.
Зручність користування. Залежність від наявності інтуїтивно зрозумілого інтерфейсу додатка, який буде зручним для користувачів різних категорій.
Надійність та технічна підтримка. Залежність від стабільної роботи програмної системи, безпеки даних та оперативної технічної підтримки для розв'язання технічних проблем.


2.4. Рамки та обмеження проєкту


2.4.1 Рамки первинного випуску
Функціонал мобільної частини:
Авторизація;
Відображення даних на мапі;
Налаштування профілю користувача.
Функціонал вебчастини:
Авторизація;
Відображення даних на мапі;
Налаштування профілю користувача;
Адміністрування користувачів;
Адміністрування роботів;
Адміністрування груп.
Функціонал IoT пристрою:
Авторизація;
Передача актуальної геолокації.
2.4.2 Рамки наступних випусків
У майбутньому планується реалізувати наступну функціональність:
Додати можливість інтеграції системи із вже наявною архітектурою замовника.
Створення нового проміжного пристрою між IoT та сервером, що дасть можливість підтримувати різні протоколи передачі даних.
Додати функціональність просторових міток.
Додати підтримку двофакторної аутентифікації.
Покращена система шифрування, особливо між IoT та сервером.
2.4.3 Обмеження та винятки
Сервіс може мати наступні виключення:
Обмежена сумісність з конкретними пристроями, програмним забезпеченням чи технічними характеристиками може призвести до обмежень у функціональності продукту.
Випуск бета-версії системи повинен бути здійснений не пізніше кінця червня 2024 року.
Користувачі не можуть користуватися функціями сервісу, поки не пройдуть авторизацію.
3 Проєктування програмної системи
3.1 Архітектурна модель системи


Проєктування програмної системи для бойової орієнтації та розпізнавання "Discerniy" включатиме визначення основних компонентів, забезпечення гнучкості та масштабованості, а також інтеграцію необхідних технологій для забезпечення функціональності та безпеки. Система складатиметься з наступних компонентів:
Server: Центральний компонент системи, який оброблятиме дані, взаємодіятиме з базами даних і забезпечуватиме взаємодію з іншими компонентами;
WebClient: Вебклієнт для доступу до системи через веббраузер;
Mobile Client: Мобільний клієнт для доступу до системи через мобільні пристрої.
IoT: Пристрої Інтернету речей, які збиратимуть і передаватимуть дані про місцеперебування об'єктів.
Система повинна розгортатися за наступною схемою (див. рис. 3.1).



Рисунок 3.1 - UML діаграма розгортання.


3.2 Гнучкість та масштабованість системи


Для досягнення гнучкості та масштабованості системи будуть використовуватися наступні підходи:
Впровадження Dependency Injection (DI): Використання DI дозволятиме зменшити залежності між компонентами та спростить їх заміну та тестування;
Використання RabbitMQ: RabbitMQ забезпечуватиме надійне асинхронне повідомлення між компонентами системи, що підвищить масштабованість та відмовостійкість;
Патерн проєктування Command: Використання патерну Command для обробки різних типів повідомлень від WebSocket (Ws) та RabbitMQ дозволятиме легко розширювати функціональність системи та покращуватиме організацію коду.


3.3 Взаємодія IoT пристроїв із сервером


IoT пристрої взаємодіятимуть із сервером за допомогою протоколів WebSocket та HTTP. WebSocket використовуватиметься для постійного зв'язку та передачі даних в режимі реального часу, тоді як HTTP використовуватиметься для запитів, що не потребуватимуть миттєвої відповіді, таких як оновлення токена доступу, отримання актуального часу.


3.4 Робота з даними


Для забезпечення ефективної роботи з даними в системі використовуватимуться такі технології:
База даних MongoDB: Для зберігання даних буде використовуватися база даних MongoDB. Вона обрана через її потужні можливості роботи з геопросторовими даними, що дозволить ефективно обробляти й запитувати координати об'єктів.
Кешування за допомогою Redis: Redis буде використовуватися для кешування часто запитуваних даних, що дозволить зменшити навантаження на базу даних MongoDB та прискорити доступ до даних.


3.5 Авторизація


Для забезпечення безпеки та контролю доступу до системи буде використовуватися авторизація за допомогою JSON Web Tokens (JWT). Це дозволить надійно перевіряти користувачів та зменшити навантаження на сервери авторизації.


3.6 Конфігурація системи


Всі константи та налаштування системи повинні бути винесеними у конфігураційні файли. Це забезпечить гнучкість налаштувань та спростить адміністрування системи.


3.7 Система дозволів


Система матиме гнучку систему дозволів, що дозволить точно контролювати доступ користувачів до різних функцій системи на різних рівнях. Це забезпечить підвищений рівень безпеки та конфіденційності даних.

4 Структура бази даних


Перед створенням серверної частини важливо чітко описати всі необхідні елементи для реалізації поставленого функціоналу. Для цього можна розробити модель даних ER, яка дозволить візуалізувати всі елементи та їхні зв'язки. Після визначення всіх необхідних елементів була створена ER модель даних (див. рис. 4.1)
Модель даних складається з наступних сутностей та молей для них:
а) користувач
користувач_id;
прізвище;
ім’я;
реєстраційний номер облікової картки платника податків;
позивний;
опис;
електронна пошта;
пароль;
дата створення;
геолокація;
компас;
секретний ключ;
перелік дозволів;
статус;
перелік груп;
рівень доступу;
зона сканування;
частота оновлення даних;
б) робот
ідентифікатор;
назва;
опис;
дата створення;
геолокація;
компас;
секретний ключ;
статус;
рівень доступу;
зона сканування;
частота оновлення даних;
група приналежності;
в) група
ідентифікатор;
дата створення;
назва;
опис;
перелік учасників;
перелік адміністраторів;
рівень доступу;
зона відповідальності.
Після того, як всі сутності визначені, слід перейти до визначення основних сценаріїв використання програмної системи. Після аналізу функціонала, котрий був визначений, були розроблені UML діаграми прецедентів (див. рис. Г.1, Г.2, Г.3 у додатку Г).



Рисунок 4.1 - ER модель даних

5 Кодування програмної системи
5.1 Опис серверної частини системи


Технології для створення серверної частини було обрано з урахуванням потреб системи та власного досвіду роботи. Тому вибір пав на фреймворк ASP.NET Core. І оскільки система повинна бути масштабованою, було прийняте рішення використовувати RabbitMQ для обміну повідомленнями між екземплярами програми. У результаті, при проєктуванні системи був використаний патерн DDD (Domain-Driven Design) як головний і Command для обробки повідомлень від RabbitMQ та WebSocket клієнтів. 
У проєкті максимально використовується “Dependency Injection”, що реалізується фреймворком ASP.NET. Всі сервіси та обробники, що реалізовані у програмі, є зареєстрованими у системі сервісів від ASP.NET.
У ролі сховища даних було обрано MongoDB, тому що у ній є вбудовані інструменти для роботи з координатами на сфері, що є дуже важливою складовою для програмної системи в цілому.
Також для зменшення навантаження на базу даних, було прийняте рішення використовувати Redis для кешування часто використовуваних даних.
Взаємодія між клієнтами та сервером відбувається за допомогою різних каналів, таких як HTTP REST API, SignalR та WebSocket. Для веб та мобільних користувачів передбачене використання HTTP REST API та SignalR, а для переносних пристроїв користувача та роботів - WebSocket та частково HTTP REST API.
5.1.1 Специфікація API

Таблиця 1 – Специфікація HTTP REST API серверної частини системи

Сутність
Метод
Посилання
Опис
Авторизація
POST
/api/auth/login
Авторизація користувача
GET
/api/auth/device/token
Генерує токен доступу для портативного пристрою користувача
/api/auth/device/refresh
Оновлює згенерований токен портативного пристрою користувача
Підтвердження
GET
/api/confirm
Використовується для підтвердження дії
Групи
GET
/api/group
Отримати перелік груп
/api/group/my
Отримати перелік грум у яких знаходиться користувач
/api/group/{id}
Інформація про групу
/api/group/{id}/detail
Детальна інформація про групу
/api/group/{id}/members
Перелік учасників групи



Продовження таблиці 1

Сутність
Метод
Посилання
Опис
Групи
GET
/api/group
Отримати перелік груп
/api/group/my
Отримати перелік грум у яких знаходиться користувач
/api/group/{id}
Інформація про групу
/api/group/{id}/detail
Детальна інформація про групу
/api/group/{id}/members
Перелік учасників групи
POST
/api/group
Створити групу
/api/group/{groupId}/members/{userId}
Додати користувача до групи
/api/group/{groupId}/admin/{userId}
Додати користувача як адміністратора
PUT
/api/group/{groupId}
Оновлення інформації про групу
/api/group/{groupId}/area
Оновлення зони відповідальності групи
DELETE
/api/group/{id}
Видалити групу
/api/group/{groupId}/members/{userId}
Вигнати користувача з групи
/api/group/{groupId}/admin/{userId}
Видалити користувача з переліку адміністраторів
Роботи
GET
/api/robots
Перелік роботів


Продовження таблиці 1

Сутність
Метод
Посилання
Опис
Роботи
GET
/api/robots/{id}
Інформація про робота
POST
/api/robots
Створити робота
PUT
/api/robots/{id}
Оновити інформацію про робота
/api/robots/self/location
Оновлення позиція робота
/api/robots/{id}/status
Оновити статус робота
/api/robots/{id}/accessLevel
Оновити рівень доступу робота
/api/robots/{id}/scanRadius
Оновити радіус сканування робота
DELETE
/api/robots/{id}
Видалити робота
Користувачі
GET
/api/users
Отримати перелік користувачів
/api/users/self
Отримати інформацію про себе
/api/users/{id}
Отримати інформацію про користувача
POST
/api/users
Створити користувача


Продовження таблиці 1

Сутність
Метод
Посилання
Опис
Користувачі
POST
/api/users/activate
Активувати зареєстрований обліковий запис користувача
PUT
/api/users/{id}
Оновити інформацію про користувача
/api/users/{id}/resetPassword
Запит на скидання пароля користувача
/api/users/self/password
Оновлення власного пароля користувача
/api/users/self/email
Оновлення власної адреси електронної пошти користувача
/api/users/{id}/permissions
Оновлення прав користувача
/api/users/{id}/status
Оновлення статусу користувача
/api/users/{id}/accessLevel
Оновлення рівня доступу користувача
/api/users/{id}/scanRadius
Оновлення радіуса сканування користувача
DELETE
/api/users/{id}
Видалення користувача


Таблиця 2 – Специфікація WebSocket серверної частини системи

Шлях
Команда
Опис
/connect/device
updateLocation
Оновлення геолокації користувача


5.1.2 Реалізація механізму публікації даних у RabbitMQ
Робота із RabbitMQ поділяється на дві частини: відправка повідомлень та отримання й обробка повідомлень. 
Для роботи із RabbitMQ було створено сервіс, який успадкований від інтерфейсу “IRabbitMqConnection” (див. розділ А.1 у додатку А), що представлений в одному екземплярі через використання Dependensy Injanction (далі - DI) в ASP.NET та зареєстрований за допомогою функції “AddSingleton”.
Щоб відправляти повідомлення, було створено сервіс-фабрику що реалізує інтерфейс “IMessagePublisherFactory” (див. розділ А.2 у додатку А), за допомогою якої можна легше створювати канати для комунікації, вона прибирає повторюваний код. Своєю чергою, канали комунікації представлені інтерфейсом “IMessagePublisher” (див. розділ А.3 у додатку А). Використаний шаблон проєктування “Factory”.
У випадку із каналом для обміну повідомленнями, що пов’язані із WebSocket, було також створено окремий сервіс, що існує у єдиному екземплярі під назвою “WebSocketMessagePublisher” (див. розділ А.4 у додатку А) він також реалізує інтерфейс “IWebSocketMessagePublisher” (див. розділ А.5 у додатку А). 
Завдяки цього, ми отримали можливість працювати із єдиним екземпляром сервісу “WebSocketMessagePublisher” (див. розділ А.4 у додатку А), який завжди тримає відкритим єдиний екземпляр “IMessagePublisher” (див. розділ А.3 у додатку А) для надсилання повідомлень у RabbitMQ на вказаний канал.
5.1.3 Реалізація механізму обробки повідомлень від RabbitMQ
Для обробки повідомлень від RabbitMQ було реалізовано “Hosted Service” під назвою “RabbitMqConsumerService” (див. розділ А.6 у додатку А). Цей сервіс отримує перелік зареєстрованих, у системі DI, обробників та налаштовує прослуховування відповідних каналів.
Самі обробники представленні у вигляді класів, що реалізують інтерфейс “IConsumerHandler” (див. розділ А.7 у додатку А). Використаний шаблон проєктування “Command”.
5.1.4 Реалізація механізму обробки повідомлень від RabbitMQ у темі про WebSocket з’єднання
Для обробки повідомлень у темі “websocket” (назва за замовчуванням, задана у файлі конфігурацій), було створено відповідний обробник “RabbitMqWebSocketHandler” (див. розділ А.8 у додатку А), що реалізує інтерфейс “IConsumerHandler” (див. розділ А.7 у додатку А). При ініціалізації цього обробника, завантажуються всі сервіси, що реалізують інтерфейс “IRabbitMqWebSocketHandler” (див. розділ А.9 у додатку А). Коли приходить повідомлення від RabbitMQ у вказану тему, обробник читає заголовок під назвою “function”, що дає змогу зрозуміти, яку реалізацію необхідно викликати.
5.1.5 Конфігурування
Для гнучкості роботи, система має можливість конфігурування, яке переставлене у вигляді файлу у форматі JSON. Доступ до конфігурацій відбувається за допомогою функціоналу ASP.NET та представлення параметрів конфігураційного файлу у вигляді класів, частина яких додана до DI як Singleton сервіси, що дозволяє швидко та просто отримати доступу до конфігурацій програми із будь-якої точки.
5.1.6 Механізм оновлення геолокації користувача
Для оновлення геолокації, користувач повинен мати свій IoT пристрій. Своєю чергою, цей пристрій передає власну геолокацію у систему.
Токен доступу до системи, пристрій оновлює за 2 хв до закінчення дії старого токену.
Процес оновлення геолокації продемонстровано на діаграмі діяльності (див. рис. 5.1).



Рисунок 5.1 - UML діаграма діяльності оновлення геолокації

5.1.7 Робота з даними
Роботу з даними можна поділити на 3 етапи: запит, обробка, репозиторій. Запит користувача на дані, викликає його обробку у сервісі, який своєю чергою звертається до репозиторію що взаємодіє з базою даних. Кешування даних відбувається на рівні сервісу.
Для роботи репозиторіїв, було створено інтерфейс “IRepository<T>” (див. розділ А.10 у додатку А) там де “T” це клас, що повинен реалізовувати інтерфейс “IIdentifier” (див. розділ А.11 у додатку А). Також, для уникнення дублювання коду, створено абстрактний клас “BaseMongoDbRepository<CollectionT>”, який реалізує інтерфейс “IRepository<T>” (див. розділ А.10 у додатку А). Від цього абстрактного класу успадковуються усі інші репозиторії.
5.1.8 Механізм роботи системи дозволів користувача
Кожен користувач має рівень доступу та перелік дозволених дій, які він може робити відносно користувачів із меншим рівнем доступу. Перелік дозволів представлений у вигляді об'єкта “ClientPermissions” (див. розділ А.12 у додатку А) що реалізує інтерфейс “IPermissionQuery” (див. розділ А.13 у додатку А). Також об'єкт “ClientPermissions” (див. розділ А.12 у додатку А) має інші властивості, такі як “Users”, “Robots” та “Groups” які мають перелік логічних (bool) властивостей.
Кожна властивість, що має відношення до дозволів, має атрибут “PermissionAttribute” (див. розділ А.14 у додатку А).
Для перевірки наявності дозволу, використовується функція “Has” класу “ClientPermissions” (див. розділ А.12 у додатку А), вона поверне виключення, якщо функція перевірки поверне брехню (false), в іншому випадку, “Has” повертає інтерфейс “IPermissionQuery” (див. розділ А.13 у додатку А). 
При оновленні дозволів користувач не може надати більше дозволів ніж має сам.
5.1.9 Створення IoT пристрою
Для створення IoT пристрою, користувач повинен мати відповідний дозвіл у системі. Створення пристрою відбувається шліхом генерації токена доступу на 30 хв (за замовчуванням, вказано у конфігураціях). Після чого цей токен завантажується у пристрій і використовуватись ним.
Коли підходить час закінчення дії токена, пристрій робить запит на оновлення, який генерує новий токен для нього. Функція генерації токенів виглядає наступним чином (див. розділ А.15 у додатку А).
5.1.10 Отримання переліку користувачів у вказаному радіусі
Для роботи з координатами використовуються вбудовані інструменти MongoDB. Їх використання прописане у функціях “GetNearRobots” (див. розділ А.16 у додатку А) та “GetNearUsers” (див. розділ А.17 у додатку А), відповідно репозиторіїв “RobotRepository” та “UserRepository”.
5.1.11 Використання SіgnalR
Для швидкого обміну даними між клієнтом та сервером було обрано SignalR, його використання обумовлене можливістю групування клієнтів та відносно простим викликом функцій із передачею параметрів.
При встановленні з’єднання, користувач додається у групу, назвою якої є його ідентифікатор (див. розділ А.18 у додатку А), що дозволяє працювати із різними з’єднаннями одного користувача, як з одним. Також користувач додається у групи, назви яких дорівнюють ідентифікаторам груп системи, у яких є цей користувач.
Після розірвання з’єднання, користувач буде видалений з усіх груп (див. розділ А.19 у додатку А).


5.2 Опис вебчастини системи


Для розробки вебклієнта, було обрано Angilar, через відносну простоту створення та наявність досвіду у використанні. Також для швидкого створення дизайну, було обрано використання Bootstrap 5.
Проєкт вебклієнта є одношаровим монолітом. 
Всі можливі сценарії використання користувацького інтерфейсу, зображено на UML діаграмі прецедентів (див. рис. 5.2).



Рисунок 5.2 - UML діаграма прецедентів користувача

5.2.1 Локалізація
Для реалізації локалізації, було використано інструменти бібліотеки “@ngx-translate”. Вебзастосунок підтримує дві мови: українську та англійську. За замовчуванням обрана англійська мова. Вибір мови користувача, зберігається локально у браузері користувача. 
Дата та час, інтерпретуються з формату UTC у локальний часовий пояс користувача.
5.2.3 Механізм роботи з таблицями
Для відображення табличних даних, було створено компонент “app-table” (див. розділ Б.1 у додатку Б). Цей компонент стандартизує відображення та пошук даних. Він використовується для відображення переліку користувачів, роботів, груп і т.д.
5.2.4 Сервіс повідомлень
Для нотифікації користувача про якісь події у системі, було розроблено сервіс повідомлень “AlertsService” (див. розділ Б.2 у додатку Б), який представлений в одному екземплярі, через використання Depenensy Injanction. Повідомлення, які публікуються цим сервісом, відображаються компонентом “app-notifications”.
Повідомлення має такі властивості як: 
- ідентифікатор - додає унікальність кожному повідомленню та можливість працювати із кожним повідомленням окремо;
- дата створення;
- дата оновлення;
- повідомлення - контент повідомлення, може бути у форматі HTML;
- індекс - впливає на порядок відображення повідомлень;
- тип - впливає на колір повідомлення;
- тривалість життя - час, через який повідомлення автоматично закриється. Якщо вказано значення менше ніж 0, то повідомлення автоматично не видалятиметься;
- дані - може містити додаткову інформацію для контексту повідомлення.
Також, повідомлення має 2 обробники подій: onclose та onclick.
5.2.5 Зміна інтерфейсу залежно від прав користувача
Користувачі із різним рівнем доступу мають різні можливості у використанні системи. Це відображається у доступі до деяких шляхів та зніми інтерфейсу.
Для перевірки рівня доступу було створено “PermissionGuard” (див. розділ Б.3 у додатку Б), який дозволяє перевіряти дозволи користувача, наступним чином (див. розділ Б.4 у додатку Б).
5.2.6 Взаємодія з API
Для взаємодії з API, було розроблено базовий клас, у якому реалізована функція обробник помилок та додавання стандартних заголовків до запиту, як то заголовок авторизації. Логіка функції наступна: якщо код відповіді дорівнює 401, то переправити користувача на сторінку авторизації (див. розділ Б.5 у додатку Б).
5.2.7 Робота з мапою
Для роботи з мапою, було використано можливості бібліотеки “Leaflet” і створено компонент під назвою “app-map”. Для обробки повідомлень від SingalR, був створений обробник (див. розділ Б.6 у додатку Б) із  використанням шаблону проєктування “Command”


5.3 Опис реалізації IoT


Програми створювалася для мікроконтролера ESP32. Для розробки було використано інтеграцію PlatformIO.
Програми використовує вбудовану файлову систему SPIFFS для зберігання конфігурацій.
Архітектура програми дозволяє використовувати різні протоколи зв'язку. У цій роботі продемонстрована робота з використанням HTTP та WebSocket.
Щоб досягти гнучкості у роботі із різними протоколами зв’язку було створено два віртуальні класи: “DataSource” (див. розділ В.1 у додатку В) та “Communicator” (див. розділ В.2 у додатку В). “DataSource” (див. розділ В.1 у додатку В) являє собою клас для отримання інформації із фізичного пристрою. Communicator використовується для комунікації із сервером.
Екземпляри цих класів використовуються у конструкторі класу “DiscerniyCore” (див. розділ В.3 у додатку В), який містить головну логіку обробки даних. Це дозволяє просто змінювати джерело даних та канал комунікації.
5.3.1 Конфігурування
Для збереження конфігурацій була використана файлова система  SPIFFS. У ній зберігається файл у форматі JSON, який містить токен доступу, інтервал оновлення даних, дату створення токена та час до якого токен є дійсним. Ці дані завантажуються при ініціалізації системи.
5.3.2 Оновлення токена
Через те, що токен доступу має обмежений час дії, система кожну хвилину робить запит на актуальний час на сервері і якщо токен доступу закінчується через 1 хвилину, то програма робить запит на оновлення токена і якщо токен було оновлено успішно, то також оновлюються конфігурації самого пристрою (див. розділ В.4 у додатку В).
5.3.3 Зміна інтервалу оновлення
Інтервал оновлення геолокації може бути змінений з панелі адміністрування користувачів. Після цієї зміни, пристрій користувача отримує команду на оновлення цього інтервалу (див. розділ В.5 у додатку В). Змінений інтервал записується у конфігураційний файл пристрою.
6 Опис розробленої програмної системи


У результаті розробки системи, було розроблено функціональні сторінки, які продемонстровані у знімках екранів нижче.
Для роботи із розробленою системою, користувач повинен бути авторизованим (див. рис. 6.1). Перший користувач створюється автоматично та має всі дозволи із рівнем доступу 999. Його дані для авторизації (без лапок), адреса електронної пошти - “email@example.com” та пароль - “password”.


Рисунок 6.1 - Знімок сторінки авторизації

Після авторизації, користувач попадає на головну сторінку, яка має вигляд мапи із панеллю навігації в горі. На цій мапі користувач може побачити зони відповідальності груп, у яких є учасником, та користувачі, що оточують його.


Рисунок 6.2 - Знімок головної сторінки

Користувач може редагувати свій профіль (див. рис. 6.2). Він може змінити пароль (див. рис. 6.3) та адресу електронної пошти(цю можливість можна налаштовувати у правах користувача).


Рисунок 6.3 - Знімок сторінки редагування профілю користувача


Рисунок 6.4 - Знімок сторінки зміну пароля

Користувач з правом читання користувачів, може перейти на сторінку переліку користувачів (див. рис. 6.5). Для перегляду детальної інформації про користувача, користувач може перейти на сторінку редагування користувача (див. рис. 6.6). Можливість редагувати поля користувачів залежить від прав  користувача, який редагує. Також, користувач не може надати тип права користувачам, яких немає сам.


Рисунок 6.5 - Знімок сторінки переліку користувачів


Рисунок 6.6 - Знімок сторінки редагування користувача

Користувачі із дозволом на додавання користувачів можуть потрапити на сторінку додавання користувачів (див. рис. 6.7).


Рисунок 6.7 - Знімок сторінки додавання користувача

Користувач із дозволом на читання роботів, може потрапити на сторінку переліку роботів (див. рис. 6.8).


Рисунок 6.8 - Знімок сторінки переліку роботів

Користувач із дозволом на читання та редагування роботів, може потрапити на сторінку редагування роботів (див. рис. 6.9).


Рисунок 6.9 - Знімок сторінки редагування роботів

Користувач із дозволом на додавання роботів, може потрапити на сторінку реєстрації роботів (див. рис. 6.9).


Рисунок 6.10 - Знімок сторінки реєстрації робота

Користувачі можуть бачити перелік груп, у яких беруть участь і якщо користувач має право на читання груп, то він може переглянути перелік усіх груп, рівень доступу яких, є меншим ніж у користувача.


Рисунок 6.11 - Знімок сторінки переліку груп

Користувачі з правом на редагування та читання груп, можуть редагувати групу на сторінці редагування (див. рис. 6.12). Тут можна змінити назву, опис, рівень доступу перелік учасників (див. рис. 6.13 та 6.14) та зону відповідальності (див. рис. 6.15).


Рисунок 6.12 - Знімок сторінки реагування груп


Рисунок 6.13 - Знімок сторінки переліку користувачів у групі


Рисунок 6.14 - Знімок сторінки редагування списку користувачів у групі


Рисунок 6.15 - Знімок сторінки редагування зони відповідальності групи


Висновки


У ході виконання курсової роботи, було розроблено програмну систему для орієнтування на полі бою “Discerniy”. Дана система призначена для забезпечення швидкої та точної ідентифікації об'єктів на полі бою, що є ключовим фактором для підвищення ефективності військових операцій та збереження життів.
Було проведено аналіз предметної області, який включав огляд наявних рішень та визначення основних проблем, що потребують вирішення. На основі цього аналізу було сформульовано вимоги до системи та обрано оптимальні технології для її реалізації.
Архітектура системи включає чотири основні компоненти: Server, WebClient, Mobile Client та IoT. Використання сучасних технологій, таких як DI, RabbitMQ, WebSocket та HTTP, забезпечує гнучкість та масштабованість системи. База даних MongoDB використовується для ефективної роботи з геопросторовими даними, а кешування за допомогою Redis дозволяє знизити навантаження на базу даних і прискорити доступ до інформації.
Для забезпечення безпеки було впроваджено авторизацію за допомогою JWT токенів, що дозволяє надійно контролювати доступ користувачів до системи. Всі константи та налаштування системи винесені у конфігураційні файли, що забезпечує гнучкість налаштувань та спрощує адміністрування системи. Система також має гнучку систему дозволів, яка забезпечує точний контроль доступу до різних ресурсів.
Розробка даної системи стала вагомим кроком вперед у сфері використання IoT технологій у військових застосуваннях, і її впровадження матиме значний позитивний вплив на безпеку та ефективність військових операцій.



Перелік посилань


Учасники проектів Вікімедіа. JSON web token – вікіпедія. Вікіпедія. URL: https://uk.wikipedia.org/wiki/JSON_Web_Token (дата звернення: 16.06.2024).
ASP.NET documentation. Microsoft Learn. URL: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (дата звернення: 16.06.2024).
ASP.NET documentation. Microsoft Learn. URL: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (дата звернення: 16.06.2024).
Bootstrap. Bootstrap · The most popular HTML, CSS, and JS library in the world. URL: https://getbootstrap.com/docs/5.0/ (дата звернення: 16.06.2024).
Design patterns. Refactoring and Design Patterns. URL: https://refactoring.guru/design-patterns (дата звернення: 16.06.2024).
Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. Design patterns. elements of reusable object-oriented software. Addsion Wesley Longman, printed in India by Eastern Press, 1999.
Leaflet – an open-source JavaScript library for interactive maps. Leaflet - a JavaScript library for interactive maps. URL: https://leafletjs.com (дата звернення: 16.06.2024).
MongoDB: the developer data platform. MongoDB. URL: https://www.mongodb.com/ (дата звернення: 16.06.2024).
PlatformIO: your gateway to embedded software development excellence. PlatformIO. URL: https://platformio.org/ (дата звернення: 16.06.2024).
RabbitMQ: One broker to queue them all | RabbitMQ. RabbitMQ: One broker to queue them all | RabbitMQ. URL: https://www.rabbitmq.com/ (дата звернення: 16.06.2024).
Redis - the real-time data platform. Redis. URL: https://redis.io/ (дата звернення: 16.06.2024).

ДОДАТОК А Реалізація серверної частини


A.1 Реалізація механізму публікації даних у RabbitMQ, інтерфейс IRabbitMqConnection

1. public interface IRabbitMqConnection : IDisposable
2. {
3. 	IModel CreateModel();
4. 	bool IsConnected { get; }
5. 	bool TryConnect();
6. }

A.2 Реалізація механізму публікації даних у RabbitMQ, інтерфейс IMessagePublisherFactory

1. public interface IMessagePublisherFactory
2. {
3. 	IMessagePublisher CreateMessagePublisher(string exchangeName, string exchangeType, string routingKey, IDictionary<string, string>? headers = default);
4. 	IMessagePublisher CreateMessagePublisher(string routingKey, IDictionary<string, string>? headers = default);
5. }

A.3 Реалізація механізму публікації даних у RabbitMQ, інтерфейс IMessagePublisher

1. public interface IMessagePublisher : IDisposable
2. {
3. 	bool IsConnected { get; }
4.
5. 	void Publish<T>(T body, IDictionary<string, string>? headers = default);
6. 	void Publish(byte[] body, IDictionary<string, string>? headers = default);
7. 	void Publish(string body, IDictionary<string, string>? headers = default);
8. }

A.4 Реалізація механізму публікації даних у RabbitMQ, клас WebSocketMessagePublisher

1. public class WebSocketMessagePublisher : IWebSocketMessagePublisher
2. {
3. 	private readonly IMessagePublisher publisher;
4.
5. 	public bool IsConnected => publisher.IsConnected;
6.
7. 	public WebSocketMessagePublisher(IMessagePublisherFactory factory, RabbitMqOptions rabbitMqOptions)
8. 	{
9.     	publisher = factory.CreateMessagePublisher(rabbitMqOptions.Queues.WebSocket);
10. 	}
11.
12. 	public void Publish<T>(T body, IDictionary<string, string>? headers = default)
13. 	{
14.     	publisher.Publish(body, headers);
15. 	}
16.
17. 	public void Publish(string message, IDictionary<string, string>? headers = default)
18. 	{
19.     	publisher.Publish(message, headers);
20. 	}
21.
22. 	public void Publish(byte[] body, IDictionary<string, string>? headers = default)
23. 	{
24.     	publisher.Publish(body, headers);
25. 	}
26.
27. 	public void Dispose()
28. 	{
29.     	publisher.Dispose();
30. 	}
31. }

A.5 Реалізація механізму публікації даних у RabbitMQ, інтерфейс IWebSocketMessagePublisher

1. public interface IWebSocketMessagePublisher : IMessagePublisher
2. {
3. }

A.6 Реалізація механізму обробки повідомлень від RabbitMQ, клас RabbitMqConsumerService

1. public class RabbitMqConsumerService : IHostedService
2. {
3. 	protected readonly IRabbitMqConnection connection;
4. 	protected readonly RabbitMqOptions options;
5. 	protected readonly IServiceProvider serviceProvider;
6.
7. 	private readonly Dictionary<string, RabbitMqConsumerHandlerRecord> handlers = new Dictionary<string, RabbitMqConsumerHandlerRecord>();
8.
9. 	public RabbitMqConsumerService(IRabbitMqConnection connection, RabbitMqOptions options, IServiceProvider serviceProvider)
10. 	{
11.     	this.connection = connection;
12.     	this.options = options;
13.     	this.serviceProvider = serviceProvider;
14. 	}
15.
16. 	public async Task StartAsync(CancellationToken cancellationToken)
17. 	{
18.     	if (!connection.IsConnected)
19.     	{
20.         	connection.TryConnect();
21.     	}
22.
23.     	RegisterHandlers();
24. 	}
25.
26. 	public Task StopAsync(CancellationToken cancellationToken)
27. 	{
28.     	foreach (var handler in handlers)
29.     	{
30.         	handler.Value.Dispose();
31.     	}
32.
33.     	handlers.Clear();
34.     	return Task.CompletedTask;
35. 	}
36.
37. 	private void RegisterHandlers()
38. 	{
39.     	var services = serviceProvider.GetServices<IConsumerHandler>();
40.     	foreach (var service in services)
41.     	{
42.         	var channel = connection.CreateModel();
43.         	handlers.Add(service.QueueName, new RabbitMqConsumerHandlerRecord(service, channel));
44.     	}
45. 	}
46. }

A.7 Реалізація механізму обробки повідомлень від RabbitMQ, інтерфейс IConsumerHandler

1. public interface IConsumerHandler
2. {
3. 	string QueueName { get; }
4. 	void Handle(object? model, BasicDeliverEventArgs args);
5. }

A.8 Реалізація механізму обробки повідомлень від RabbitMQ у темі про WebSocket з’єднання, клас RabbitMqWebSocketHandler
1. public class RabbitMqWebSocketHandler : IConsumerHandler
2. {
3. 	public string QueueName { get; }
4.
5. 	protected readonly IServiceProvider serviceProvider;
6. 	protected readonly ILogger<RabbitMqWebSocketHandler> logger;
7.
8. 	protected IDictionary<string, IRabbitMqWebSocketHandler> handlers = new Dictionary<string, IRabbitMqWebSocketHandler>();
9.
10. 	public RabbitMqWebSocketHandler(RabbitMqOptions options, IServiceProvider serviceProvider, ILogger<RabbitMqWebSocketHandler> logger)
11. 	{
12.     	QueueName = options.Queues.WebSocket;
13.     	this.serviceProvider = serviceProvider;
14.     	this.logger = logger;
15.
16.     	RegisterHandlers();
17. 	}
18.
19. 	public async void Handle(object? model, BasicDeliverEventArgs args)
20. 	{
21.     	try
22.     	{
23.         	IBasicProperties properties = args.BasicProperties;
24.
25.         	string functionName = Encoding.UTF8.GetString(properties.Headers["function"] as byte[] ?? throw new ArgumentNullException("function is null"));
26.
27.         	if (!handlers.ContainsKey(functionName))
28.         	{
29.             	return;
30.         	}
31.         	await handlers[functionName].Handle(model, args);
32.     	}catch (Exception ex)
33.     	{
34.         	this.logger.LogError(ex, "Error while handling RabbitMQ message");
35.     	}
36. 	}
37.
38. 	private void RegisterHandlers()
39. 	{
40.     	var services = serviceProvider.GetServices<IRabbitMqWebSocketHandler>();
41.     	foreach (var service in services)
42.     	{
43.         	handlers.Add(service.FunctionName, service);
44.     	}
45. 	}
46. }

A.9 Реалізація механізму публікації даних у RabbitMQ, інтерфейс IRabbitMqWebSocketHandler

1. public interface IRabbitMqWebSocketHandler
2. {
3. 	string FunctionName { get; }
4. 	Task Handle(object? model, BasicDeliverEventArgs args);
5. }

A.10 Робота з даними, інтерфейс IRepository<T>

1. public interface IRepository<T> where T : class, IIdentifier
2. {
3. 	Task<T> Create(T entity);
4. 	Task<T?> Get(string id);
5. 	Task<PageResponse<T>> GetAll(PageRequest request);
6. 	Task<T> Update(T entity);
7. 	Task<T?> Delete(string id);
8.
9. 	Task<long> GetCountAsync();
10. 	Task<bool> Exists(string id);
11. }

A.11 Реалізація механізму публікації даних у RabbitMQ, інтерфейс IIdentifier

1. public interface IIdentifier
2. {
3. 	public string Id { get; set; }
4. }

A.12 Механізм роботи системи дозволів користувача, клас ClientPermissions

1. public class ClientPermissions : IPermissionQuery
2. {
3. 	public static ClientPermissions Default => new ClientPermissions();
4. 	public static ClientPermissions Admin => new ClientPermissions
5. 	{
6.     	Users = UsersInteractionPermissions.Admin,
7.     	Robots = RobotsInteractionPermissions.Admin,
8.     	Groups = GroupsInteractionPermissions.Admin
9. 	};
10.
11. 	[Permission("Users")]
12. 	public UsersInteractionPermissions Users { get; set; } = new UsersInteractionPermissions();
13. 	[Permission("Robots")]
14. 	public RobotsInteractionPermissions Robots { get; set; } = new RobotsInteractionPermissions();
15. 	[Permission("Groups")]
16. 	public GroupsInteractionPermissions Groups { get; set; } = new GroupsInteractionPermissions();
17.
18. 	/// <summary>
19. 	/// Check if the client has the permission. If not, throw an exception with the specified message.
20. 	/// </summary>
21. 	/// <param name="parameter">Validation function</param>
22. 	/// <param name="errorMessage">Error message</param>
23. 	/// <returns>Itself</returns>
24. 	/// <exception cref="UnauthorizedAccessException"></exception>
25. 	public IPermissionQuery Has(Func<ClientPermissions, bool> parameter, string? errorMessage = null)
26. 	{
27.     	if(parameter(this))
28.     	{
29.         	return this;
30.     	}
31.     	throw new UnauthorizedAccessException(errorMessage ?? "Permission denied");
32. 	}
33. 	/// <summary>
34. 	/// Function for updating permissions. If the executor has not enough permissions, the function will throw an <see cref="BadHttpRequestException"/> exception.
35. 	/// </summary>
36. 	/// <param name="newPermissions"></param>
37. 	/// <param name="executorsPermissions"></param>
38. 	public void Update(ClientPermissions newPermissions, ClientPermissions executorsPermissions)
39. 	{
40.     	if(!executorsPermissions.Users.CanUpdatePermissions)
41.     	{
42.         	return;
43.     	}
44.     	Users.Update(newPermissions, executorsPermissions);
45.     	Robots.Update(newPermissions, executorsPermissions);
46.     	Groups.Update(newPermissions, executorsPermissions);
47. 	}
48. }

A.13 Механізм роботи системи дозволів користувача, інтерфейс IPermissionQuery

1. public interface IPermissionQuery
2. {
3. 	IPermissionQuery Has(Func<ClientPermissions, bool> parameter, string? errorMessage = null);
4. }

A.14 Механізм роботи системи дозволів користувача, клас PermissionAttribute

1. public class PermissionAttribute : Attribute
2. {
3. 	public string Name { get; }
4.
5. 	public PermissionAttribute(string permissionName)
6. 	{
7.     	Name = permissionName;
8. 	}
9. }

A.15 Створення IoT пристрою, функція GenerateDeviceJwtToken

1. private SecurityToken GenerateDeviceJwtToken(UserModel user)
2. {
3. 	var tokenHandler = new JwtSecurityTokenHandler();
4. 	var key = Encoding.UTF8.GetBytes(jwtOption.Secret);
5.
6. 	var claims = new[]
7. 	{
8.             	new Claim(ClaimTypes.NameIdentifier, user.Id),
9.             	new Claim(ClaimTypes.Role, "device")
10.         	};
11.
12. 	var tokenDescriptor = new SecurityTokenDescriptor
13. 	{
14.     	Subject = new ClaimsIdentity(claims),
15.     	Issuer = jwtOption.Issuer,
16.     	Audience = jwtOption.Audience,
17.     	Expires = DateTime.UtcNow.AddMinutes(jwtOption.DeviceExpiresInMinutes),
18.     	SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
19. 	};
20.
21. 	var token = tokenHandler.CreateToken(tokenDescriptor);
22.
23. 	return token;
24. }

A.16 Отримання переліку користувачів у вказаному радіусі, функція GetNearRobots

1. public async Task<IList<LocationResponse>> GetNearRobots(GeoJson2DProjectedCoordinates coordinates, double radius)
2. {
3. 	var filter = Builders<RobotModel>.Filter.NearGeo(x => x.Location, coordinates.Easting, coordinates.Northing, maxDistance: radius);
4. 	var result = await Collection
5.     	.Find(filter)
6.     	.ToListAsync();
7. 	return result.Select(x => new LocationResponse(x)).ToList();
8. }

A.17 Отримання переліку користувачів у вказаному радіусі, функція GetNearUsers

1. public async Task<IList<LocationResponse>> GetNearUsers(GeoJson2DProjectedCoordinates coordinates, double radius)
2. {
3. 	var filter = Builders<UserModel>.Filter.NearGeo(x => x.Location, coordinates.Easting, coordinates.Northing, maxDistance: radius, minDistance: 0);
4. 	var result = await Collection
5.     	.Find(filter)
6.     	.ToListAsync();
7. 	return result.Select(x => new LocationResponse(x)).ToList();
8. }

A.18 Використання SіgnalR, функція OnConnectedAsync

1. public override async Task OnConnectedAsync()
2. {
3. 	this.authService.SetHttpContext(Context.GetHttpContext() ?? throw new ArgumentNullException());
4. 	var client = await authService.GetUser();
5. 	if (client != null)
6. 	{
7.     	await Groups.AddToGroupAsync(Context.ConnectionId, client.Id);
8.     	foreach (var group in client.Groups)
9.     	{
10.         	await Groups.AddToGroupAsync(Context.ConnectionId, group);
11.     	}
12.     	if (!client.WebSocketConections.Contains(Context.ConnectionId))
13.     	{
14.         	client.WebSocketConections.Add(Context.ConnectionId);
15.         	await clientRepository.Update(client);
16.     	}
17. 	}
18. 	await base.OnConnectedAsync();
19. }

A.19 Використання SіgnalR, функція OnDisconnectedAsync

1. public override async Task OnDisconnectedAsync(Exception? exception)
2. {
3. 	this.authService.SetHttpContext(Context.GetHttpContext() ?? throw new ArgumentNullException());
4. 	var client = await authService.GetUser();
5. 	if (client != null)
6. 	{
7.     	await Groups.RemoveFromGroupAsync(Context.ConnectionId, client.Id);
8.     	foreach (var group in client.Groups)
9.     	{
10.         	await Groups.RemoveFromGroupAsync(Context.ConnectionId, group);
11.     	}
12.     	if (client.WebSocketConections.Contains(Context.ConnectionId))
13.     	{
14.         	client.WebSocketConections.Remove(Context.ConnectionId);
15.         	await clientRepository.Update(client);
16.     	}
17. 	}
18. 	await base.OnDisconnectedAsync(exception);
19. }


ДОДАТОК Б Реалізація вебклієнта


Б.1 Механізм роботи з таблицями, копмоненм TableComponent

1. @Component({
2.   selector: 'app-table',
3.   templateUrl: './table.component.html',
4.   styleUrls: ['./table.component.css']
5. })
6. export class TableComponent {
7.   @Input()
8.   columns: TableColumn[] = [];
9.   @Input()
10.   searchFilters: SearchFilter[] = [];
11.   @Input()
12.   hasNextPage: boolean = false;
13.   @Input()
14.   isLoading: boolean = false;
15.   @Input()
16.   data: TableRecord[] = [];
17.   @Input()
18.   enableSearch: boolean = true;
19.   @Input()
20.   actions: TableRecordAction[] = [
21. 	{
22.   	name: 'table.view',
23.   	style: 'primary',
24.   	type: 'button',
25.   	event: this.viewInfoClick.bind(this)
26. 	}
27.   ];
28.   @Output()
29.   onSearch: EventEmitter<SearchFilter[]> = new EventEmitter<SearchFilter[]>();
30.   @Output()
31.   onLoadMore: EventEmitter<void> = new EventEmitter<void>();
32.   @Output()
33.   onViewInfo: EventEmitter<string> = new EventEmitter<string>();
34.
35.   public searchClick() {
36. 	this.onSearch.emit(this.searchFilters);
37.   }
38.
39.   public resetClick() {
40. 	this.searchFilters.forEach(filter => {
41.   	if (filter.defaultValue !== undefined) {
42.     	filter.value = filter.defaultValue;
43.   	} else {
44.     	filter.value = '';
45.   	}
46. 	});
47. 	this.onSearch.emit(this.searchFilters);
48.   }
49.
50.   public loadMoreClick() {
51. 	this.isLoading = true;
52. 	this.onLoadMore.emit();
53.   }
54.
55.   public viewInfoClick(id: string) {
56. 	this.onViewInfo.emit(id);
57.   }
58.
59.   getColumnById(id: number): TableColumn | undefined {
60. 	return this.columns[id];
61.   }
62. }

Б.2 Сервіс повідомлень AlertsService

1. @Injectable({
2.   providedIn: 'root'
3. })
4. export class AlertsService {
5.   private alerts: AlertRecord[] = [];
6.   constructor() {
7. 	console.warn('AlertsService created');
8.   }
9.
10.   public get list(): Alert[] {
11. 	return this.alerts.sort((a, b) => a.index - b.index);
12.   }
13.
14.   public add(alert: Alert) {
15. 	const alertRecord = new AlertRecord(alert);
16. 	alertRecord.lifetime = alertRecord.lifetime ?? 5000;
17. 	if (alertRecord.lifetime > 0) {
18.   	alertRecord.timer = window.setTimeout(() => {
19.     	this.remove(alertRecord);
20.   	}, alertRecord.lifetime);
21. 	}
22. 	this.alerts.push(alertRecord);
23.
24. 	return alertRecord;
25.   }
26.
27.   public get(id: string): Alert | undefined {
28. 	return this.alerts.find(a => a.id === id);
29.   }
30.
31.   public remove(alert: Alert | string) {
32. 	const id = typeof alert === 'string' ? alert : alert.id;
33. 	const index = this.alerts.findIndex(a => a.id === id);
34. 	if (index >= 0) {
35.   	const alertRecord = this.alerts[index];
36.   	if (alertRecord.timer) {
37.     	clearTimeout(alertRecord.timer);
38.   	}
39.   	if (alertRecord.onclose) {
40.     	alertRecord.onclose(alertRecord);
41.   	}
42.   	this.alerts.splice(index, 1);
43. 	}
44.   }
45.
46.   public removeAll() {
47. 	this.alerts.forEach(a => {
48.   	if (a.timer) {
49.     	clearTimeout(a.timer);
50.   	}
51. 	});
52. 	this.alerts = [];
53.   }
54. }

Б.3 Зміна інтерфейсу залежно від прав користувача, PermissionGuard

1. const DATA_VALIDATION_FUNCTION = '$permissionValidationFunction';
2.
3. @Injectable({
4. 	providedIn: 'root'
5. })
6. export class PermissionGuard implements CanActivate {
7.
8. 	constructor(private userApiService: UserApiService) {
9. 	}
10.
11. 	async canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Promise<boolean | UrlTree> {
12.     	if(!this.userApiService.isAuthenticated){
13.         	return false;
14.     	}
15.     	var user = await this.userApiService.getSelf();
16.     	let func = route.data[DATA_VALIDATION_FUNCTION] as PermissionValidateFunction;
17.     	return func(user.permissions);
18. 	}
19.
20. 	static has(func: PermissionValidateFunction): any {
21.     	let data: any = {};
22.     	data[DATA_VALIDATION_FUNCTION] = func;
23.     	return data;
24. 	}
25.
26. }
27. export type PermissionValidateFunction = (permission: ClientPermissions) => boolean;

Б.4 Зміна інтерфейсу залежно від прав користувача, налаштування роутингу

 1. { path: 'new', component: UserAdministrationComponent, canActivate: [PermissionGuard], data: { ...PermissionGuard.has((p) => p.users.canCreate), mode: 'CREATE' } },

Б.5 Взаємодія з API

1. export abstract class BaseApi extends StorageService {
2. 	public abstract get apiUrl(): string;
3. 	public get baseUrl(): string {
4.     	return environment.apiUrl + this.apiUrl;
5. 	}
6.	 
7. 	protected get<T>(url: string) {
8.     	let request = fetch(`${this.baseUrl}/${url}`, {
9.         	headers: this.getHeaders()
10.     	});
11.     	return this.toPromise<T>(request);
12. 	}
13.
14. 	protected post<T>(url: string, body: any) {
15.     	let request = fetch(`${this.baseUrl}/${url}`, {
16.         	method: 'POST',
17.         	headers: this.getHeaders(),
18.         	body: JSON.stringify(body)
19.     	});
20.     	return this.toPromise<T>(request);
21. 	}
22.
23. 	protected put<T>(url: string, body: any) {
24.     	let request = fetch(`${this.baseUrl}/${url}`, {
25.         	method: 'PUT',
26.         	headers: this.getHeaders(),
27.         	body: JSON.stringify(body)
28.     	});
29.     	return this.toPromise<T>(request);
30. 	}
31.
32. 	protected delete<T>(url: string) {
33.     	let request = fetch(`${this.baseUrl}/${url}`, {
34.         	method: 'DELETE',
35.         	headers: this.getHeaders()
36.     	});
37.     	return this.toPromise<T>(request);
38. 	}
39.
40. 	private toPromise<T>(func: Promise<Response>): Promise<HttpResponse<T>> {
41.     	return new Promise<HttpResponse<T>>((resolve, reject) => {
42.         	func.then(response => {
43.             	if (response.ok) {
44.                 	response.json().then(body => {
45.                     	resolve({ ok: response.ok, status: response.status, body: body });
46.                 	});
47.             	} else {
48.                 	if (response.headers.get('Content-Type') === 'application/json') {
49.                     	response.json().then(body => {
50.                         	resolve({ ok: response.ok, status: response.status, body: body });
51.                     	});
52.                 	} else {
53.                     	response.text().then(body => {
54.                         	resolve({ ok: response.ok, status: response.status, body: {} as T });
55.                     	});
56.                 	}
57.             	}
58.             	if(response.status === 401) {
59.                 	this.token = null;
60.             	}
61.         	});
62.     	});
63. 	}
64.
65. 	protected toDataResponse<T>(response: Promise<HttpResponse<T>>): Promise<T> {
66.     	return new Promise<T>((resolve, reject) => {
67.         	response.then(res => {
68.             	if (res.ok) {
69.                 	resolve(res.body as T);
70.             	} else {
71.                 	reject(res.body);
72.             	}
73.         	});
74.     	});
75. 	}
76.
77.
78. 	private getHeaders() {
79.     	let headers: [string, string][] = [];
80.     	headers.push(['Content-Type', 'application/json']);
81.     	if (this.token) {
82.         	headers.push(['Authorization', `Bearer ${this.token}`]);
83.     	}
84.     	return headers;
85. 	}
86. }

Б.6 Робота з мапою

1. export class MapSignalREvents {
2. 	private map!: L.Map;
3. 	private signalR: SignalRService;
4. 	private handlers: BaseHandler[] = [];
5.
6. 	constructor(signalR: SignalRService) {
7.     	this.signalR = signalR;
8. 	}
9.
10. 	public setMap(map: L.Map) {
11.     	this.map = map;
12. 	}
13.
14. 	public init(){
15.     	this.handlers.push(new MarkCreatedHandler());
16.     	this.handlers.push(new MarkUpdatedHandler());
17.     	this.handlers.push(new MarkDeletedHandler());
18.
19.     	this.registerHandlers();
20. 	}
21.
22. 	public getHandler(command: string): BaseHandler | undefined {
23.     	return this.handlers.find(handler => handler.command === command);
24. 	}
25.
26. 	private registerHandlers(){
27.     	this.handlers.forEach(handler => {
28.         	this.signalR.on(handler.command, (request) => {
29.             	handler.execute({
30.                 	signalR: this.signalR,
31.                 	map: this.map,
32.                 	request: request
33.             	});
34.         	});
35.     	});
36. 	}
37. }


ДОДАТОК В Реалізація IoT пристрою


В.1 Архітектура програми, клас DataSource 

1. class DataSource
2. {
3. public:
4. 	virtual void init() = 0;
5. 	virtual void tick() = 0;
6.
7. 	virtual Position getPosition() = 0;
8. };

В.2 Архітектура програми, клас Communicator

1. class Communicator
2. {
3. public:
4. 	virtual void init(DeviceInfo* config, std::function<void(const String& message)>onMessage) = 0;
5. 	virtual void tick() = 0;
6.
7. 	virtual void sendPosition(const Position& position) = 0;
8. 	virtual DeviceInfo getDeviceInfo() = 0;
9. 	virtual bool updateToken() = 0;
10. 	virtual long getServerTime() = 0;
11. };

В.3 Архітектура програми, клас DiscerniyCore

1. class DiscerniyCore
2. {
3. private:
4. 	DataSource* dataSources;
5. 	Communicator* communicator;
6. 	DeviceInfo* deviceInfo;
7. 	unsigned long lastUpdateLocation;
8.
9. 	unsigned long serverTime;
10. 	unsigned long lastUpdateServerTime;
11.
12. 	void loadDeviceInfo();
13. 	void updateDeviceInfo();
14.
15. 	void onMessage(const String& message);
16. public:
17. 	DiscerniyCore(DataSource* dataSources, Communicator* communicator);
18. 	~DiscerniyCore();
19.
20. 	void init();
21. 	void tick();
22. };

В.4 Оновлення токена, логіка оновлення

1. if(millis() - lastUpdateServerTime > 1000 * 60 || deviceInfo->expiration - 60 < serverTime)
2. {
3. 	serverTime = communicator->getServerTime();
4. 	lastUpdateServerTime = millis();
5.
6. 	if(deviceInfo->expiration - 60 < serverTime)
7. 	{
8.     	    if(communicator->updateToken())
9.     	    {
10.         	updateDeviceInfo();
11.        }
12. 	}
13. }

В.5 Зміна інтервалу оновлення, обробка команди оновлення інтервалу 

1. void DiscerniyCore::onMessage(const String& message)
2. {
3. 	LOG("Message received: " + message);
4.
5. 	StaticJsonDocument<512> doc;
6. 	deserializeJson(doc, message);
7.
8. 	String command = doc["Command"].as<String>();
9.
10. 	LOG("Command: " + command);
11. 	LOG("Payload: " + message);
12.
13. 	if(command == "updateUserUpdateLocationInterval"){
14.     	this->deviceInfo->updateInterval = doc["Payload"]["LocationSecondsInterval"].as<unsigned long>();
15.     	updateDeviceInfo();
16.     	LOG("Update interval: " + String(this->deviceInfo->updateInterval));
17. 	}
18. }


ДОДАТОК Г Діаграми




Рисунок Г.1 - UML діаграма прецедентів користувача




Рисунок Г.2 - UML діаграма прецедентів робота



Рисунок Г.3 - UML діаграма прецедентів IoT

